use std::io::prelude::*;
use std::cmp;
use std::fs::File;
const RAM_SIZE:usize = 4096;
const SCREEN_WIDTH:usize = 64;
const SCREEN_HEIGHT:usize = 32;
const REGISTERS:usize = 16;
const FONT_DATA:[u8;16*5] = [
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
];
const PROGRAM_START:usize = 0x200;
pub struct Chip8 {
    ram:[u8;RAM_SIZE],
    pc:u16,
    pub screen_state:[bool;SCREEN_WIDTH*SCREEN_HEIGHT],
    i_reg:u16,
    v_reg:[u16;REGISTERS],
    stack:Vec<u16>,
    delay_timer:u8,
    sound_timer:u8,
}
impl Chip8 {
    pub fn new() -> Chip8 {
        let mut chip8 = Chip8 {
            ram:[0;RAM_SIZE],
            pc:PROGRAM_START as u16,
            screen_state:[false;SCREEN_WIDTH*SCREEN_HEIGHT],
            i_reg:0,
            v_reg:[0;REGISTERS],
            stack:Vec::new(),
            delay_timer:0,
            sound_timer:0,
        };
        const FONT_START:usize = 0x050;
        for (i,font_byte) in FONT_DATA.iter().enumerate() {
            chip8.ram[FONT_START + i] = *font_byte;
        }
        chip8
    }
    pub fn read_file(&mut self, path:&str) {
        let rom:File = File::open(path).expect("Failed to read file");
        let mut ind = PROGRAM_START;
        for byte in rom.bytes() {
            self.ram[ind] = byte.expect("Failed to read byte from file");
            ind += 1;
        }
    }
    pub fn step(&mut self) {
        let higher_byte:u16 = self.ram[self.pc as usize] as u16;
        let lower_byte:u16 = self.ram[(self.pc + 1) as usize] as u16;
        let opcode:u16 = higher_byte << 8 | lower_byte;
        let nibbles = ((opcode & 0xF000) >> 12, (opcode & 0x0F00) >> 8, 
                       (opcode & 0x00F0) >> 4, opcode & 0x000F);
        let x = (opcode & 0x0F00) >> 8;
        let y = (opcode & 0x00F0) >> 4;
        let n = opcode & 0x000F;
        let nn = opcode & 0x00FF;
        let nnn = opcode & 0x0FFF;
        self.pc += 2;
        match nibbles {
            (0,0,0xE,0) => {
                for i in 0..self.screen_state.len() {
                    self.screen_state[i] = false;
                }
            }
            (1,_,_,_) => self.pc = nnn,
            (6,_,_,_) => self.v_reg[x as usize] = nn,
            (7,_,_,_) => self.v_reg[x as usize] += nn,
            (0xA,_,_,_) => {
                self.i_reg = nnn;
            }
            (0xD,_,_,_) => {
                const WIDTH:u16 = 8;
                self.v_reg[0xF_usize] = 0;
                let img_x = self.v_reg[x as usize] % 64;
                let img_y = self.v_reg[y as usize] % 64;

                let right_end = cmp::min(n + img_y,SCREEN_HEIGHT as u16);
                let bottom_end = cmp::min(WIDTH + img_x,SCREEN_WIDTH as u16);
                for row in img_y..right_end {
                    let sprite_addr = (self.i_reg + row - img_y) as usize;
                    let row_data:u8 = self.ram[sprite_addr];
                    for col in img_x..bottom_end{
                        let ind:usize = (row * SCREEN_WIDTH as u16 + col) as usize;
                        let shift = (WIDTH - 1) - (col - img_x);
                        if row_data & (1 << shift) > 0 {
                            if self.screen_state[ind] {
                                self.screen_state[ind] = false;
                                self.v_reg[0xF_usize] = 1;
                            } else {
                                self.screen_state[ind] = true;
                            }
                        }
                    }
                }
            }
            _ => println!("unimplemented opcode {:#06X}", opcode),
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_file_read() {
        const LOGO: [u8; 0x104] = [
            0x00, 0xE0, 0x61, 0x01, 0x60, 0x08, 0xA2, 0x50, 0xD0, 0x1F, 0x60, 0x10, 0xA2, 0x5F, 0xD0, 0x1F, 
            0x60, 0x18, 0xA2, 0x6E, 0xD0, 0x1F, 0x60, 0x20, 0xA2, 0x7D, 0xD0, 0x1F, 0x60, 0x28, 0xA2, 0x8C, 
            0xD0, 0x1F, 0x60, 0x30, 0xA2, 0x9B, 0xD0, 0x1F, 0x61, 0x10, 0x60, 0x08, 0xA2, 0xAA, 0xD0, 0x1F, 
            0x60, 0x10, 0xA2, 0xB9, 0xD0, 0x1F, 0x60, 0x18, 0xA2, 0xC8, 0xD0, 0x1F, 0x60, 0x20, 0xA2, 0xD7, 
            0xD0, 0x1F, 0x60, 0x28, 0xA2, 0xE6, 0xD0, 0x1F, 0x60, 0x30, 0xA2, 0xF5, 0xD0, 0x1F, 0x12, 0x4E, 
            0x0F, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x1F, 0x3F, 0x71, 0xE0, 0xE5, 0xE0, 0xE8, 0xA0, 
            0x0D, 0x2A, 0x28, 0x28, 0x28, 0x00, 0x00, 0x18, 0xB8, 0xB8, 0x38, 0x38, 0x3F, 0xBF, 0x00, 0x19, 
            0xA5, 0xBD, 0xA1, 0x9D, 0x00, 0x00, 0x0C, 0x1D, 0x1D, 0x01, 0x0D, 0x1D, 0x9D, 0x01, 0xC7, 0x29, 
            0x29, 0x29, 0x27, 0x00, 0x00, 0xF8, 0xFC, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x49, 0x4A, 0x49, 
            0x48, 0x3B, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x01, 0xF0, 0x30, 0x90, 0x00, 0x00, 0x80, 
            0x00, 0x00, 0x00, 0xFE, 0xC7, 0x83, 0x83, 0x83, 0xC6, 0xFC, 0xE7, 0xE0, 0xE0, 0xE0, 0xE0, 0x71, 
            0x3F, 0x1F, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x39, 0x38, 0x38, 0x38, 0x38, 0xB8, 0xB8, 
            0x38, 0x00, 0x00, 0x31, 0x4A, 0x79, 0x40, 0x3B, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 
            0x00, 0x00, 0xA0, 0x38, 0x20, 0xA0, 0x18, 0xCE, 0xFC, 0xF8, 0xC0, 0xD4, 0xDC, 0xC4, 0xC5, 0x00, 
            0x00, 0x30, 0x44, 0x24, 0x14, 0x63, 0xF1, 0x03, 0x07, 0x07, 0x77, 0x57, 0x53, 0x71, 0x00, 0x00, 
            0x28, 0x8E, 0xA8, 0xA8, 0xA6, 0xCE, 0x87, 0x03, 0x03, 0x03, 0x87, 0xFE, 0xFC, 0x00, 0x00, 0x60, 
            0x90, 0xF0, 0x80, 0x70
        ];
        let mut hard_coded = Chip8::new();
        let mut from_file = Chip8::new();
        for i in 0..LOGO.len() {
            hard_coded.ram[PROGRAM_START + i] = LOGO[i];
        }
        from_file.read_file("roms/1-chip8-logo.ch8");
        for i in 0..RAM_SIZE {
            assert_eq!(hard_coded.ram[i],from_file.ram[i]);
        }
    }
}
